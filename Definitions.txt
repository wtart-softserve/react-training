1. JavaScript types:
  Primitives:
    (In JS, a primitive is data that is not an object and has no methods. All primitive are immutable, i.e, they cannot be altered 
        (like objects, arrays))
    - Boolean 
        (type which can have only values: true or false)
    - Undefined 
        (primitive value automatically assigned to variables that have just been declared or to formal arguments 
            for which there are no actual arguments)
    - Null 
        (represents a reference that points, to a nonexistent or invalid object or address)
    - Number 
        (is a numeric data type in the double precision 64-bit floating point)
    - String 
        (In any computer programming language, a string is sequence of characters used to represent text. In JavaScript, 
            a String is one of the primitive values and the String object is a wrapper around String primitive)
    - Symbol
        (A value having the data type 'symbol' can be reffered to as a 'symbol value'.
         In the JS run-time environment, a symbol value is created by invoking the function
         Symbol, which dynamically produces an anonymous, unique value. A 
         symbol may be used as an object property. In some programming languages the symbol
         data type is referred to as an 'atom'
         Well-know symbols:
          The Symbol class has constants for so-called well-know symbols. These
          symbols let you configure how JS treats an object, by using them as property
          keys. Examples of well-known symbols are: Symbol.iterator for array-like
          objects, or Symbol.search for string objects).
  Object 
   (Object refers to a data structure containing data and instructions for working 
    with the data. Object sometimes refer to real-world things, for example a car or map
    object in a racing game. JS, Java, C++, Python and Ruby are examples of object-oriented
    programming languages)

2. Differences between Null and Undefined
   Undefined means a variable has been declared but has not yet been assigned a value.
   On the other hand, null is an assignment value. It can be assigned to a variable as a
   representation of no value.

3. Closure
    A clousure is the combination of a function and the lexical environment within which 
    that function was declared. The environment consists of any local variables that were 
    in-scope at the time the closure was created.

4. OOP
    From the OOP perspective, and application is a collection of 'objects' that comunnicate
    with each other.

    - New Operator
      The new operator lets developers create an instance of a user-defined object type
      or of one of the built-in object types that has a consctructor function. The new
      keyword does the following things:
       1. Creates a blank, plain JavaScript object;
       2. Links this object to another object; (Object.assign)
       3. Passes the newly created object from Step 1 as the this context;
       4. Returns this if the function doesn't return its own object.

       Object.assign() - method is used to copy the values of all enumerable own
       properties from one or more source objects to a target object. It will return
       the target object.

       Object.create() - method creates a new object, using and existing object
       as the prototype of the newly created object.

5.     2. Create two classes an Animal, a Rabbit and build dependency between them by (Object.create and without Object.create)

const animal = {
  name: '',
  age: 0
}

let rabbit = Object.create(animal);
rabbit = Object.assign({}, animal);

SOLID 
Single responsibility principle - A class should have only a single responsibility, that is,
only changes to one part of the software's specification should be able to affect the specification
of the class.

Open-closed principle - 'Software entities ... should be open for extension, but closed for
modification'.

Liskov substitution principle - 'Objects in a program should be replaceable with instances
of their subtypes without altering the correctnes of that program.

Interface segregation principle - 'Many client-specific interfaces are better than one
general-purpose interface.'

Dependency inversion principle - One should 'depend upon abstractions, [not] concretions.'

Virtual DOM
  Virtual dom is in-memory reprsesentation of Real DOM. It is lightweight JavaScript
  object which is copy of Real DOM.
  Updating virtual DOM in React is faster because ReactJS uses:
   - Efficient diff algorithm
   - Batched update operations
   - Efficient update of sub tree only
   - Uses observable to detect change

HOC 
 Similar to the decorator pattern, a function that takes a component as the first
 parameter and returns a new component.
  pros:
    - Imortantly they provide a way to reuse code when using ES6 classes.
    - No longer have method name clashing if two HOC implement the same one.
    - It is easy to make small reusable units of code, thereby supporting the 
      single responsibility principle
    - Apply multiple HOCs to one component by composing them. The readability can be
      improve using a compose function like Recompose.

  cons:
    - There is still indirection issue, however, not about which HOC is changing the 
      state but which one is providing a certain prop.
    - It is possible two HOC could be using the same prop meaning one would
      overwrite the other silently.
    - Boilerplate code like setting the displayName with the HOC function name
    - Ensure all relevant props are passed through to the component.
    - Hoist static methods from the wrapped component
    - It is easy to compose several HOCs together and then this creates deeply
      nested tree making it difficult to debug.

Render Props:
  A render prop is where a component's prop is assigned a function and this is called
  in the render method of the component. Calling the function can return a React
  element or component to render.
    pros:
      - Reuse code across components when using ES6 classes.
      - The lowest level of indirection - it's clear which component is called
        and the state is isolated.
      - No naming collision issues for props, state and class methods.
      - No need to deal with boiler code and hoisting static methods.
    
    cons:
      - Caution using shouldComponentUpdate as the render prop might close overwrite
        data it is unaware of.
      - There could also be minor memory issues when defining a closure for every 
        render. But be sure to measure first before making performance changes as 
        it might not be and issue for your app.
      - Another small annoyance is the render props callback is not so neat in JSX
        as it needs to be wrapped in an expression. Rendering the result of an 
        HOC does look clener.

Hooks - are new addition in React 16.8. They let you use state and other React features
without writing a class.

JSX - it is syntax extension to JavaScript.

React events
  - you cannot return false to prevent default behavior in React.

  SyntheticEvent - a cross-browser wrapper around the browser's native event.
  It has the same interface as the browser's native event, including
  stopPropagation() and preventDefault(), except the events work identically
  across all browsers.

  Event Pooling - the SyntheticEvent is pooled. This means that the SyntheticEvent
  object will be reused and all properties will be nullified after the event callback
  has been invoked. This is for performance reasons. As such, you cannot access
  the event in an asynchronus way.

Controlled Components - In HTML, form elements such as <input>, <textarea>, and 
<select> typically maintain their own state and update it based on user inpu. In
React, mutable state is typically kept in the state property of components, and only
updated with setState(). We can combine the two by making the React state be the 
'single source of truth'. Then the React component that renders a form also controls
what happens in that form on subsequent user input. An input form element whose value
is controlled by React in this way is called a 'controlled component'.

Thinking in React:
 1. Break UI Into A Component Hierarchy
 2. Build A Static Version in React
 3. Identify The Minimal (but complete) Representation Of UI state
 4. Identify Where Your State Should Live
 5. Add Inverse Data Flow 

Context - provides a way to share values like between components without having
to explicitly pass prop through every level of the tree.

If you only want to avoid passing some props through many levels, component
composition is often a simpler solution than context.

const MyContext = React.createContext(defaultValue);
<MyContext.Provider value={ some value } />

Error Boundares - are React components that catch JavaScript errors anywhere in their
child component tree, log those errors, and display a fallback UI instead of the component
three that crashed. Error boundries catch errors during rendering, in lifecycle methods,
and in constructors of the whole tree below them.
  Error boundries do not catch errors for:
    - Event handlers
    - Asynchronous code
    - Server side rendering
    - Errors thrown in the error boundary itself
  
  A class componetn becomes an error boundary if it defines either (or both)
  of the lifecycle methods: 
    static getDerivedStateFromError()
    componentDidCatch()


Forwarding Refs 
  Ref forwarding is an opt-in feature that lets some components take a ref they 
  receive, and pass it further down ( in other words, 'forward' it) to a child.
    - We creat React ref by calling React.createRef and assign it to a ref variable.
    - We pass our ref down to <FancyButton ref={ref} /> by specifying it 
      as a JSX attribute.
    - React passes the ref to the (props, ref) => ...function inside 
      forwardRef as a second argument.

Fragments - a common pattern in React is for a component to return multiple elements.
Fragments let you group a list of children without adding extra nodes to the DOM.


Portals - provide a first-class way to render children into DOM node that exists
outside the DOM hierarchy of the parent component.
  ReactDom.createPortal(child, container);


ReactDom - package provides DOM-specific methods that can be used at the top level
of your app and as an escape hatch to get outside of the React model if you need to.
Most of your componets should not need to use this module.

React lifecycle:
  - Mounting
    - constructor()
    - static getDerivedStateFromProps()
    - render()
    - componentDidMount()
  - Updating
    - static getDerivedStateFromProps()
    - shouldComponentUpdate()
    - render()
    - getSnapshotBeforeUpdate()
    - componentDidUpdate()
  - Unmounting
    - componentWillUnmount()
  - Error 
    - static getDerivedStateFromError()
    - componentDidCatch()


CSS 
  Specificity - is a process of determining which css rule will be applied to an element.
  It actually determines which rules will take precedence.
  Inline style usallly wins then ID then class vlaue (or pseudo-class or attribute selector),
  universal selector (*) has no specificity.

  Transition - allows to add an effect while changing from one style to another. You can set 
  the which property you want to transition, duration, how you want to transit 
  (linear, ease, ease-in, ease-out, cubic-bezier) and delay when transition will start.
  You can transition more than one property by comma separation.

  Filter - allows you to render DOM element, image or video. You can choose from: grayscale,
  blur, opacity, brightness, contrast.

  Positions
    - static (Default value. Elements render in order, as they appear in the document flow)
    - absolute (The element is positioned relative to its first positioned (not static)
      ancestor element)
    - fixed (The element is positioned relative to the browser window)
    - relative (The element is positioned relative to its normal position)
    - inital (Sets this property to its default value)
    - sticky (The element is positioned based on the user's scroll position.
      A sticky element toggles between relative and fixed, depending on the scroll position.
      It is positioned relative until a given offset position is met in the viewport -
      then it 'sticks' in place (like position: fixed))

JS
  this - when used in global scope equels the global object, which is window in the browser.
  When used inside a function, the value of this is dynamically determined when the function
  is called and its value equals the context of the function.

  Promises 
    async/await
      - calling an async function always results in a promise 
      - await waits for a promise to be fullfiled, then returns its value.
      - you can pass non-promise values to await 
      - await it may be only used within async functions 
      - await will wait until at least the next tick before returning, even when awaiting 
        already-fulfilled promises or non-promise values.
    
    Combining promises 
      - Use all() to turn an array of promises into a promise to an array.
        Promise.all([promise, promise, promise]);
        If any promise is rejected, the error will be passed through.
      - Use race() instead to pass through the first settled promise 
        Promise.race([promise, promise]);
    
    Making promises 
      - The function passed to new Promise will be executed synchronously.
        new Promise((resolve, reject) => {
          doImportantStuff((error, value) => {
            if (error) {
              reject(error);
            } else {
              resolve(value);
            }
          })
        });
  
  HTTP Requests
    Preflight request 
      A CORS preflight request is a CORS request that checks to see if the CORS protocol is 
      understood.

      It is an OPTIONS request, using three HTTP request headers: Access-Control-Request-
      Method, Access-Control-Request-Headers, and the Origin header.

      A preflight request is automatically issued by browser, when needed. In normal cases, 
      front-end developers don't need to craft such requests themselves.

      Access-Control-Allow-Origin: *
    Fetch()
     fetch(url).then();

     Response Types:
      When we make a fetch request, the response will be given a response.type 
      of 'basic', 'cors' or 'opaque'. These types indicate where the resource has come from 
      and can be used to inform how you should treat the response object.

      When a request is made for a resource on the same origin, the response will have 
      basic type and there aren't any restrictions on what you can view from the response.

      If a request is made for a resource on another origin which returns the CORs headers, then 
      the type is cors. cors and basic responses are almost identical except that a cors 
      response restricts the headers you can view to 'Cache-Control', 'Content-Language',
      'Content-Type', 'Expires', 'Last-Modified', and 'Pragma'.

      An opaque response is for a request made for a resource on a different origin that 
      doesn't return CORS headers. With an opaque response we won't be able to read the data 
      returned or view the status of the request, meaning we can't check if the request was 
      successful or not.

     fetch mode:
      - same-origin (only succeeds for requests for assets on the same origin, all other
        requests will reject)
      - cors (will allow requests for assests on the same-origin and other origins which return
        the appropriate CORs headers)
      - cors-with-forced-preflight (will always perform a preflight check before making the
        actual request)
      - no-cors (is intended to make requests to other origins that do not have CORS and 
        result in an opaque response, but as stated, but as stated, this isn't possible 
        in the window global scope at the moment)
      
      fetch(url, {mode})
      fetch(url, {
        mehtod: 'post',
        headers: {'Content-type'},
        body: ''
      })

    Axios
      is a JavaScript library used to make http requests from node.js or XMLHttpRequests
      from the browser and it supports the Promise API that is native to JS. Another feature 
      that it has over .fetch() is that it performs automatic transforms of JSON data.
      
      - is more secure, featuring built in Cross Site Forgery protection
      - has better error handling - When your backend returns the status code "500 internal
        server error", fetch will treat it as the same as status code "200 OK"
      - has interceptors - allow you to run code or modify the request and/or response before
        the request and/or response has started. Axios is supports promises and has the ability
        to run async operations before request is made or before the promise of .hten or .catch
        are executed. For the first example, we use a config.
      - has the ability to monitor POST Request Proggress 
        axios.post(url, data, {
          onUploadProgress: ({total, loaded}) => {
            //update progress
          }
        })
      - supports a wider range of browsers - chrome, safari, opera, edge and internet explorer
        version 8 and newer.

Docker 
  is defined as the platform for containerizing the applications to isolate it from each 
  other in order to ensure high availability and more efficiency irrespective of the 
  environments such as Development, Testing or Production. All the application related
  dependencies such as libraries, jar files, server related configurations,
  infrastructure-related elements will be packaged and formed as container called containerized
  application which does not need any dependency and works independently. I ensures the 
  application to be run irrespective of the external factors. Containers in Docker have 
  support from Docker Engine and Host Operating System to support all the operational or 
  infrastructural related dependencies.

  Components of Docker Architecture:
    The Docker works on client-server architecture. The Docker client establishes communication
    with the Docker Daemon. The Docker client and Daemon can run on the same system.
    A Docker client can also be connected to a remote Docker Deamon. The different types 
    of Docker components in a Docker architecture: 
      Client: this performs Docker build pull and run operations to establish 
      communication with the Docker Host. The Docker command uses Docker API to call the 
      queries to be run.
      
      Host: this component contains Docker Daemon, Containers and its images. The images
      will be the kind of metadata for the applications which are containerized in the 
      containers. The Docker Daemon establishes a connection Registry.

      Registry: this component will be storing the Docker images. The public registries are
      Docker Hub and Docker Cloud which can be used by anyone.
  
  Docker Container
    A Docker Container is a form of encapsulation to the application which holds all the
    dependencies which share the kernel with other containers in the duration of running 
    the isolated processes on the host operating system. A Docker container can be created 
    by creating a Docker image. These Docker images can be run after that using Docker 
    commands. Docker containers are the instances of the Docker images at the runtime. Docker
    images can be stored in any public hosts or private hosts like Docker hub. Docker Image 
    is a set of files which can be run in an isolated process.
  
  Docker Image and Docker Hub 
    The Docker Image is a set of files and a combination of parameters which will allow 
    creating the instances to run in separate containers as an isolated process. 
    The Docker hub is kind of repository to the images where these images can be stored 
    and this access is public. The Docker run command can be used to create the instance 
    called container which can be run using the Docker image. Docker hub is the largest public 
    repository of the image containers which is being maintained by the community of
    developers and individual contributors.

  Docker Functionalities
    - it simplifies the configuration and provides ease at infrastructure level configuration 
    - it manages the code pipeline easily which provides consistent environment and stability 
      in the application 
    - it enables the isolation of the application 
    - it improves the productivity of the developer by allowing the developer to solely 
      concentrate on business logic
    - it enables rapid deployment in the form of virtualization at the operating system level.
    - it reduces the utilization of multiples servers in the form of containerization.
  
  Docker Registry 
    A Docker Registry is a place where all the Docker Images will be stored and Docker Cloud 
    and Docker Hub are the public registries where these images can be hosted upon. The 
    Docker hub is the default storage for the Docker Images. An own registery can also 
    be set up as per the requirement. Docker Data Center (DDC) can also be used which
    includes DTR (Docker Trusted Registery). Docker store will provide the feature of buying 
    and selling the Docker images.

  Docker Container Lifecycle 
    1. Create a container 
    2. Run the Docker container 
    3. Pause the Container 
    4. Unpause the Container 
    5. Start the Container 
    6. Stop the Container 
    7. Restart the Container 
    8. Kill the Container 
    9. Destroy the Container 

  Docker Objects 
    The Docker Objects are Docker Images, Services, and Docker Containers. A Docker Image is a 
    read-only template with the configuration on runtime instrucions for the Docker container.
    The Services allow scaling the containers across the different Docker Daemons.
  
  Docker Namespaces 
    The Namespaces in Docker is a technology which provides isolated workspace called the 
    Container. Namespaces provide a layer of isolation for the Docker containers.
  
  Important Docker Commands 
    dockerd - to launch Docker daemon 
    build - to build an image file for docker 
    create - to create a new container 
    kill - to kill a container 
    commit - to create a new image from container changes

TDD 
  is a software development process that relies on the repetition of a very short development 
  cycle: requirements are turned into very specific test cases, then the sftware is improved 
  to pass the new tests.

Redux 
  Benefits 
   - maintainability (maintenance of Redux becomes easier due to strict code structure and
     organisation)
   - organization (code organisation is very strict hence the stability of the code
     is high which intern increases to be much easier)
   - server rendering (this is useful, particularly to the preliminary render, which keeps
     up a better user experience or search engine optimization. The server-side created
     stores are forwarded to the client side)
   - developer tools (it is highly traceable so changes in position and changes in the 
     application all such instances make the developers have a real-time experience.)
   - ease of testing (the first rule of writing testable code is to write small functions
     that do only one thing and that are independent. Redux's code is made of functions
     that used to be: small, pure and isolated)
  
  Functional Programing Concepts
    - functions are treated as First class objects
    - capable to pass functions in the format of arguments
    - capable to control flow using, recursions, functions and arrays 
    - helper functions such as reducer and map filter are used 
    - allows linking functions together
    - the state doesn't change 
    - prioritize the order of executing the code is not really necessary
  
  Redux Change of State
    For release of an action, a change in state to an application is applied, this ensures an
    intent to change the state will be achieved.
    Example:
      1. The user clicks a button in the application.
      2. A function is called in the form of component.
      3. So now an action gets dispatched by the relative container
      4. This happens because the prop (which was jus called in the container) is tied to an
         action dispatcher using mapDispatchToProps (in the container).
      5. Reducer on capturing the action it intern executes a function and this function returns
         a new state with specific changes.
      6. The state change is known by the container and modifies a specific prop in the 
         component as result of the mapStateToProps function.
  
  Typical Flow Of Data In Redux 
    Call-back from UI component dispatches an action with a payload, these dispatched actions are
    intercepted and received by the reducers. This interception will generate a new application
    state. From here the actions will be propagated down through a hierarchy of components from 
    Redux store. The below diagram depicts the entity structure of a redux+react setup.
  
  Redux Store 
    The store holds the application state and supplies the helper methods for accessing the 
    state. Register listeners and dispatch actions. There is only on Store while using Redux.
    The store is configured via the createStoreFunction. The single store represents the entire
    state. Reducers return a state via action.
  
  Redux Reducers 
    The state of a store is updated by means of reducer functions. A stable collection of a 
    reducers form a store and each of the stores maintains a separate state associated for 
    itself. To update the array of donors, we should define donor application.
    The inital state and action are received by the reducers. Based on the action type, it 
    returns a new state for the store. The state maintained by reducers are immutable.
    The below-given reducer it holds the current state and action as an argument for it
    and then returns the next.
  
  Redux Workflow Features 
    Reset: Allow to reset the state of the store
    Revert: Roll bakc to the last committed state 
    Sweep: All disabled actions that you might have fired by mistake will be removed 
    Commit: makes the current state the initial state 
  
  Redux Actions 
    Actions in Redux are functions which return an action object (payload). The action type
    an the action data are packed in the action object. Which also allows a donor to be added 
    to the system. Actions send data between the store and application. All information's 
    retrieved by the store are produced by the actions.